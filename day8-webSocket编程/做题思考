用户加密认证(完成)
允许同时多用户登录(完成)
每个用户有自己的家目录 ，且只能访问自己的家目录
对用户进行磁盘配额，每个用户的可用空间不同
允许用户在ftp server上随意切换目录
允许用户查看当前目录下文件
允许上传和下载文件，保证文件一致性
文件传输过程中显示进度条
附加功能：支持文件的断点续传

初始框架：
	1.bin
		1.执行程序
	2.core
		1.主逻辑交互程序
		2.认证程序
		3.操作数据库程序.
		4.创建用户程序.
	3.db
		1.用户登录信息
			1.一个一个文件
			2.用户名和密码.
		2.每个用户有自己的家目录
			1.一个用户一个家目录.(home)
		3.用户的可用空间。
	4.log
		1.操作行为

	自己的家目录下存有一个文件,该文件存储家目录的总空间和可用空间. 

1.用户认证(服务端认证) 前提:接收到客户端发送的用户名和密码.(完成)
	1.从/db/auth匹配客户端的用户名的文件.如果匹配不到,则返回False.
	2.取出匹配到的文件中的数据.
	3.验证密码.(如果密码不正确,则返回False)
	4.返回True.
2.创建用户:(服务器端创建)前提:已接受到客户端发送的用户名和密码.(完成)
	1.将接收到的用户名同/db/auth中的文件名匹配,(如果匹配到,返回False)
	2.在/db/auth中以接受到的用户名为名创建一个新文件.
	3.将接受的用户名和密码写入文件中.
	4.返回True.	




2.客户端类:
	1.连接服务器.(完成)
	2.登录(完成)
		1.输入用户名和密码,跟着命令一起json化传给服务端.
	3.注册(完成)
		1.输入用户名和密码.
		2.收到服务端的信息.
	4.切换目录(完成)
		1.调用客户端的cd函数,与服务端的cd函数对应起来.
		2.一整句执行语句拆分为执行命令和路径两部分,将其编写成json序列化字典,然后传给服务器处理.
	
	5.上传文件
		1.对句柄参数进行分析:
			1.如果是'>>',就提示未登录,并且传送json对象给服务端.
			2.如果不是'>>',就表示已登录,继续接下来的操作.
				1.设置一个当前路径
				2.一整句执行语句拆分为执行命令和文件名两部分
				3.将当前路径加上文件名形成一个绝对路径.
				4.判断绝对路径存在:
					1.不存在:
						1.传送json对象给服务器.
						2.输出上传文件不存在的消息.
					2.存在:
						1.传送json对象给服务器.
						  1.(磁盘足够):接受到服务端的上传请求.
						  2.将文件内容全部读取出来存储到一个变量中.
						  3.将文件内容一次性发送给服务端.
						  
						  1.(磁盘不足够):接受到服务端的磁盘空间不够的提示
						  2.输出提示.
	
	6.下载文件
		1.如果是'>>',就提示未登录.
		2.如果不是'>>',就表示已登录,继续接下来的操作.
			1.一整句执行语句拆分为执行命令和文件名两部分,将其编写成json序列化字典,然后传给服务器处理.
			2.接受服务端发回来消息(如果请求的文件存在,则是文件字节大小,否则则是字符'-1'.)
			3.发送一条消息通知服务端,开始发送文件.
			4.接受文件内容,并显示进度条.
			5.当接受完文件内容后,将文件内容写到一个文件中.
	7.显示进度条(完成)
	8.查看当前目录下的文件.(完成)
		1.分析传进来的句柄参数.
			1.如果是'>>',就提示未登录.
			2.如果不是'>>',就表示已登录,继续接下来的操作.
				1.客户端将执行语句拆分成执行命令和文件名两部分,将其编写成json序列化对象,然后传给服务端.
				2.接受到服务端发回来的消息,并将该消息转成整型值并将其存储到一个变量中.
					1.如果该变量为-1:
						1.则输出文件不存在的消息.
					2.如果变量不为-1:
						1.然后发送一句提示信息通知服务端开始发送数据.
						2.客户端将服务端发送来的内容全部接收后,显示内容.


1.服务端类:
	1.登录(完成)
		1.接受客户端发来的json化字典,先反序列化,然后根据执行命令调用login函数.
		2.验证用户名和密码.
		3.记录日志信息,并返回客户端相应提示.
		4.切到自己的家目录下.
		
	2.注册(完成)
		1.接受客户端发来的json化字典,先反序列化,然后根据执行命令调用register函数.
		2.存储新用户信息到文件系统中,
		3.为新用户创建家目录和分配磁盘空间.
		4.记录日志信息,并返回客户端相应提示.
		5.4.切到自己的主目录下.
	3.切换目录(完成)
		1.接受客户端发来的json化字典,先反序列化,然后根据执行命令调用cd函数.
		2.设置一个基本路径(不变)和当前路径(可变).
		//3.对当前路径进行合法性判断(保证每一个连接进来的用户只能访问自己的家目录)
		4.当前路径合法后, 需要对执行内容进行分类处理.
		5.设定一个函数,接受一个路径参数,用来除去多余的路径,将剩下的路径,
		6.分类处理:
			1.cd '':
				1.将currentPath以'/'分割成列表,然后将列表中的第一个元素取出来,重新拼起来.
				2.返回重新拼成的路径

			2.cd ..:	1.判断当前路径是否是主目录
					1.yes,直接返回当前路径
					2.no,将currentPath以'/'分割成列表,去除倒数两个元素.然后将列表拼成路径(专门写一个将列表拼成路径的函数)
					3.返回重新拼成的路径


			3.cd 'path':
				1.将接受到的路径参数与当前路径对比,去掉重复的部分,将不重复的部分拼接到当前路径中.
				2.检查执行内容是否存在用户的主目录中.
				3.如果存在则返回当前路径.
	
	4.上传文件
		1.对句柄参数做处理,
		  1.如果句柄参数为'>>',则返回句柄参数
		  2.如果句柄参数不为'>>',则继续接下来的操作.
		    1.上传文件不存在
			1.返回句柄参数.
		    2.上传文件存在
			1.取出客户端发来的infoDict, 将文件大小取出来.
			2.与用户的磁盘的可用空间进行比较.(设置路径)
			  1.如果磁盘的可用空间不足:
				1.给客户端发送空间不足的提示.
				2.返回执行句柄.
			  2.如果磁盘的可用空间足够:
				1.给客户端发送上传请求
				2.接受客户端发送过来的文件内容.
				3.将文件内容写进文件中.
				4.返回执行句柄.
	5.下载文件
		1.对句柄参数做处理,
			1.如果句柄参数为'>>',则返回句柄参数
			2.如果句柄参数不为'>>',则继续接下来的操作.
				1.设置一个基本路径和当前路径.
				2.对客户端发来的字典处理,将命令和文件名分别提取出来.
				3.将基本路径、用户名和文件名拼接起来,形成一个完整路径
				4.检查该文件是否存在于用户的磁盘下:
					1.不存在:
						1.返回一条提示给用户,告诉用户该文件不存在.
						2.返回执行句柄
					2.存在:
						1.通过完整路径打开该文件,将该文件的全部内容读取出来,存储到一个变量中.
						2.计算文件内容大小,将文件内容大小传给客户.
						3.接受客户的发送请求.
						4.将文件一次性传给用户.
						5.返回执行句柄.
	7.显示进度条(完成)
	8.查看当前目录(完成)
		1.接收客户端发来的json对象,将其分解成执行命令和内容,通过执行命令调用对应的函数,客户端发送来的字典和执行句柄做参数.
		2.对句柄参数做处理,
			1.如果句柄参数为'>>',则返回句柄参数
			2.如果句柄参数不为'>>',则继续接下来的操作.
				1.对客户端发来的字典进行分类处理:
				2.设置一个基本路径和当前路径
					1.ls '':查看当前目录.
						1.讲基本路径和当前路径拼接起来得到一个完整路径
						1.执行"ls '完整路径'",将得到的内容存储在一个变量中.
						2.计算得到内容的大小,告知客户端.
						3.等待到客户端的发送请求,然后一次性发送得到的内容.
					2.ls 'content':查看相对路径下的目录.
						1.对相对路径进行判断,将基本路径和相对路径拼接成一个完整的路径,然后检查该路径是否存在.
							1.如果路径不存在
								1.给客户端返回False
								2.返回执行句柄
							2.如果路径存在
								1.执行"ls '完整路径'"命令.将得到的内容存储在一个变量中.
								2.计算得到内容的大小,告知客户端.
								3.等待到客户端的发送请求,然后一次性发送得到的内容.
每个用户有自己的家目录 ，且只能访问自己的家目录
对用户进行磁盘配额，每个用户的可用空间不同
	服务端:

	客户端:
			

标准码(如403),客户端类,反射,服务器不切换目录,只是返回的效果是切换效果.os.chdir()
